Title,Description,Code,Difficulty,Topics,Calls/TestCases,Test Cases,,,Tests
3 sum Closest,"Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

 

Example 1:

Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
Example 2:

Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).
 

Constraints:

3 <= nums.length <= 500
-1000 <= nums[i] <= 1000
-104 <= target <= 104","class Solution {
    public int threeSumClosest(int[] nums, int target) {
       
    }
}",Medium,"Array
Two Pointers
Sorting","([-1,2,1,-4]) = 1
([0, 0, 0]) = 1",,,,
Two Sum,"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 

Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.
 

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?","class Solution {
    public int[] twoSum(int[] nums, int target) {
        
    }
}",Easy,"Array
Hash Table","([2,7,11,15]) = 9
([3,2,4]) = 6
([3, 3]) = 6",,,,"
"
Median of Two Sorted Arrays,"Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).
 
Example 1:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.

Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.

 
Constraints:
nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106","class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
       
    }
}",Hard,"Array
Binary Search
Divide and Conquer","([1, 3], [2]) = 2
([1, 2], [3, 4]) = 2.5",,,,"
"
Count Substrings,"You are given two strings word1 and word2.

A string x is called valid if x can be rearranged to have word2 as a 
prefix
.

Return the total number of valid 
substrings
 of word1.

Note that the memory limits in this problem are smaller than usual, so you must implement a solution with a linear runtime complexity.

 

Example 1:

Input: word1 = ""bcca"", word2 = ""abc""

Output: 1

Explanation:

The only valid substring is ""bcca"" which can be rearranged to ""abcc"" having ""abc"" as a prefix.

Example 2:

Input: word1 = ""abcabc"", word2 = ""abc""

Output: 10

Explanation:

All the substrings except substrings of size 1 and size 2 are valid.

Example 3:

Input: word1 = ""abcabc"", word2 = ""aaabc""

Output: 0

 

Constraints:

1 <= word1.length <= 106
1 <= word2.length <= 104
word1 and word2 consist only of lowercase English letters.","class Solution {
    public long validSubstringCount(String word1, String word2) {
        return validSubstringCount(word1, word2);
        
    }
}",Hard,"Hash Table
String
Sliding Window","(""bcca"", ""abc"") = 1
(""abcabc"", ""abc"") = 10
(""abcabc"", ""aaabc"") = 0",,,,
1314. Matrix Block Sum,"Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:

i - k <= r <= i + k,
j - k <= c <= j + k, and
(r, c) is a valid position in the matrix.
 

Example 1:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[12,21,16],[27,45,33],[24,39,28]]
Example 2:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
Output: [[45,45,45],[45,45,45],[45,45,45]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n, k <= 100
1 <= mat[i][j] <= 100","class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        
    }
}",Medium,"Array
Matrix
Prefix Sum","([[1,2,3],[4,5,6],[7,8,9]], 1) = [[12,21,16],[27,45,33],[24,39,28]]
([[1,2,3],[4,5,6],[7,8,9]], 2) = [[45,45,45],[45,45,45],[45,45,45]]",,,,
334. Increasing Triplet Subsequence,"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.

 

Example 1:

Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
Example 2:

Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.
Example 3:

Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.
 

Constraints:

1 <= nums.length <= 5 * 105
-231 <= nums[i] <= 231 - 1
","class Solution {
    public boolean increasingTriplet(int[] nums) {
        
    }
}",Medium,"Array
Greedy","([1,2,3,4,5]) = true
([5,4,3,2,1]) = false
([2,1,5,0,4,6]) = true",,,,